{"ast":null,"code":"import { createEffect, ofType } from '@ngrx/effects';\nimport { of } from 'rxjs';\nimport { catchError, concatMap, map, switchMap, tap } from 'rxjs/operators';\nimport { login, loginFailure, loginSuccess, logout, register, registerFailure, registerSuccess } from '../actions/authenticator.actions';\nimport { clearNotification, updateErrorMsg, updateRespMsg } from '../actions/notification.actions';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@ngrx/effects\";\nimport * as i2 from \"src/app/services/auth.service\";\nimport * as i3 from \"@angular/router\";\nimport * as i4 from \"@ngrx/store\";\nexport let AuthEffects = /*#__PURE__*/(() => {\n  class AuthEffects {\n    constructor(actions$, authService, router, store) {\n      this.actions$ = actions$;\n      this.authService = authService;\n      this.router = router;\n      this.store = store;\n      this.register$ = createEffect(() => {\n        return this.actions$.pipe(ofType(register), switchMap(action => this.authService.register(action.user).pipe(map(resp => {\n          return registerSuccess({\n            respMsg: resp\n          });\n        }), catchError(resp => {\n          return of(registerFailure({\n            respMsg: resp.error\n          }));\n        }))));\n      });\n      this.registerSuccess$ = createEffect(() => {\n        return this.actions$.pipe(ofType(registerSuccess), tap(() => this.router.navigate(['/auth/login'])), concatMap(response => {\n          return of(updateRespMsg({\n            respMsg: response.respMsg['message']\n          }));\n        }));\n      });\n      this.registerFailure$ = createEffect(() => {\n        return this.actions$.pipe(ofType(registerFailure), switchMap(response => {\n          return of(updateErrorMsg({\n            errorMsg: response.respMsg['message'] || 'Unknown Error'\n          }));\n        }));\n      });\n      this.login$ = createEffect(() => {\n        return this.actions$.pipe(ofType(login), concatMap(action => this.authService.login(action.username, action.password).pipe(map(user => loginSuccess({\n          user\n        })), catchError(error => of(loginFailure(error))))));\n      });\n      this.loginSuccess$ = createEffect(() => {\n        return this.actions$.pipe(ofType(loginSuccess), tap(() => this.router.navigate(['/'])), switchMap(response => {\n          return of(updateRespMsg({\n            respMsg: 'Login Successful.'\n          }));\n        }));\n      });\n      this.loginFailure$ = createEffect(() => {\n        return this.actions$.pipe(ofType(loginFailure), switchMap(response => {\n          return of(updateErrorMsg({\n            errorMsg: 'User not found.'\n          }));\n        }));\n      });\n      this.logout$ = createEffect(() => {\n        return this.actions$.pipe(ofType(logout), tap(() => {\n          return this.router.navigate(['/']);\n        }), map(() => clearNotification()) // Dispatch actions to clear state of previous user info\n        );\n      });\n    }\n  }\n\n  AuthEffects.ɵfac = function AuthEffects_Factory(t) {\n    return new (t || AuthEffects)(i0.ɵɵinject(i1.Actions), i0.ɵɵinject(i2.AuthService), i0.ɵɵinject(i3.Router), i0.ɵɵinject(i4.Store));\n  };\n  AuthEffects.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: AuthEffects,\n    factory: AuthEffects.ɵfac\n  });\n  return AuthEffects;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}